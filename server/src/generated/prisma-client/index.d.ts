// Code generated by Prisma (prisma@1.34.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  lesson: (where?: LessonWhereInput) => Promise<boolean>;
  module: (where?: ModuleWhereInput) => Promise<boolean>;
  note: (where?: NoteWhereInput) => Promise<boolean>;
  sprint: (where?: SprintWhereInput) => Promise<boolean>;
  track: (where?: TrackWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  lesson: (where: LessonWhereUniqueInput) => LessonNullablePromise;
  lessons: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Lesson>;
  lessonsConnection: (args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LessonConnectionPromise;
  module: (where: ModuleWhereUniqueInput) => ModuleNullablePromise;
  modules: (args?: {
    where?: ModuleWhereInput;
    orderBy?: ModuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Module>;
  modulesConnection: (args?: {
    where?: ModuleWhereInput;
    orderBy?: ModuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ModuleConnectionPromise;
  note: (where: NoteWhereUniqueInput) => NoteNullablePromise;
  notes: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Note>;
  notesConnection: (args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NoteConnectionPromise;
  sprint: (where: SprintWhereUniqueInput) => SprintNullablePromise;
  sprints: (args?: {
    where?: SprintWhereInput;
    orderBy?: SprintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Sprint>;
  sprintsConnection: (args?: {
    where?: SprintWhereInput;
    orderBy?: SprintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SprintConnectionPromise;
  track: (where: TrackWhereUniqueInput) => TrackNullablePromise;
  tracks: (args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Track>;
  tracksConnection: (args?: {
    where?: TrackWhereInput;
    orderBy?: TrackOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TrackConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createLesson: (data: LessonCreateInput) => LessonPromise;
  updateLesson: (args: {
    data: LessonUpdateInput;
    where: LessonWhereUniqueInput;
  }) => LessonPromise;
  updateManyLessons: (args: {
    data: LessonUpdateManyMutationInput;
    where?: LessonWhereInput;
  }) => BatchPayloadPromise;
  upsertLesson: (args: {
    where: LessonWhereUniqueInput;
    create: LessonCreateInput;
    update: LessonUpdateInput;
  }) => LessonPromise;
  deleteLesson: (where: LessonWhereUniqueInput) => LessonPromise;
  deleteManyLessons: (where?: LessonWhereInput) => BatchPayloadPromise;
  createModule: (data: ModuleCreateInput) => ModulePromise;
  updateModule: (args: {
    data: ModuleUpdateInput;
    where: ModuleWhereUniqueInput;
  }) => ModulePromise;
  updateManyModules: (args: {
    data: ModuleUpdateManyMutationInput;
    where?: ModuleWhereInput;
  }) => BatchPayloadPromise;
  upsertModule: (args: {
    where: ModuleWhereUniqueInput;
    create: ModuleCreateInput;
    update: ModuleUpdateInput;
  }) => ModulePromise;
  deleteModule: (where: ModuleWhereUniqueInput) => ModulePromise;
  deleteManyModules: (where?: ModuleWhereInput) => BatchPayloadPromise;
  createNote: (data: NoteCreateInput) => NotePromise;
  updateNote: (args: {
    data: NoteUpdateInput;
    where: NoteWhereUniqueInput;
  }) => NotePromise;
  updateManyNotes: (args: {
    data: NoteUpdateManyMutationInput;
    where?: NoteWhereInput;
  }) => BatchPayloadPromise;
  upsertNote: (args: {
    where: NoteWhereUniqueInput;
    create: NoteCreateInput;
    update: NoteUpdateInput;
  }) => NotePromise;
  deleteNote: (where: NoteWhereUniqueInput) => NotePromise;
  deleteManyNotes: (where?: NoteWhereInput) => BatchPayloadPromise;
  createSprint: (data: SprintCreateInput) => SprintPromise;
  updateSprint: (args: {
    data: SprintUpdateInput;
    where: SprintWhereUniqueInput;
  }) => SprintPromise;
  updateManySprints: (args: {
    data: SprintUpdateManyMutationInput;
    where?: SprintWhereInput;
  }) => BatchPayloadPromise;
  upsertSprint: (args: {
    where: SprintWhereUniqueInput;
    create: SprintCreateInput;
    update: SprintUpdateInput;
  }) => SprintPromise;
  deleteSprint: (where: SprintWhereUniqueInput) => SprintPromise;
  deleteManySprints: (where?: SprintWhereInput) => BatchPayloadPromise;
  createTrack: (data: TrackCreateInput) => TrackPromise;
  updateTrack: (args: {
    data: TrackUpdateInput;
    where: TrackWhereUniqueInput;
  }) => TrackPromise;
  updateManyTracks: (args: {
    data: TrackUpdateManyMutationInput;
    where?: TrackWhereInput;
  }) => BatchPayloadPromise;
  upsertTrack: (args: {
    where: TrackWhereUniqueInput;
    create: TrackCreateInput;
    update: TrackUpdateInput;
  }) => TrackPromise;
  deleteTrack: (where: TrackWhereUniqueInput) => TrackPromise;
  deleteManyTracks: (where?: TrackWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  lesson: (
    where?: LessonSubscriptionWhereInput
  ) => LessonSubscriptionPayloadSubscription;
  module: (
    where?: ModuleSubscriptionWhereInput
  ) => ModuleSubscriptionPayloadSubscription;
  note: (
    where?: NoteSubscriptionWhereInput
  ) => NoteSubscriptionPayloadSubscription;
  sprint: (
    where?: SprintSubscriptionWhereInput
  ) => SprintSubscriptionPayloadSubscription;
  track: (
    where?: TrackSubscriptionWhereInput
  ) => TrackSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type SprintOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ModuleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC";

export type LessonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "details_ASC"
  | "details_DESC";

export type Role = "ADMIN" | "USER";

export type NoteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "details_ASC"
  | "details_DESC";

export type TrackOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "details_ASC"
  | "details_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "role_ASC"
  | "role_DESC"
  | "username_ASC"
  | "username_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface LessonUpdateManyWithoutModuleInput {
  create?: Maybe<
    LessonCreateWithoutModuleInput[] | LessonCreateWithoutModuleInput
  >;
  delete?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  set?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  disconnect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
  update?: Maybe<
    | LessonUpdateWithWhereUniqueWithoutModuleInput[]
    | LessonUpdateWithWhereUniqueWithoutModuleInput
  >;
  upsert?: Maybe<
    | LessonUpsertWithWhereUniqueWithoutModuleInput[]
    | LessonUpsertWithWhereUniqueWithoutModuleInput
  >;
  deleteMany?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  updateMany?: Maybe<
    | LessonUpdateManyWithWhereNestedInput[]
    | LessonUpdateManyWithWhereNestedInput
  >;
}

export type LessonWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LessonUpdateManyWithWhereNestedInput {
  where: LessonScalarWhereInput;
  data: LessonUpdateManyDataInput;
}

export interface LessonWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  module?: Maybe<ModuleWhereInput>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  OR?: Maybe<LessonWhereInput[] | LessonWhereInput>;
  NOT?: Maybe<LessonWhereInput[] | LessonWhereInput>;
}

export interface ModuleUpdateWithoutLessonsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  sprint?: Maybe<SprintUpdateOneRequiredWithoutModulesInput>;
}

export interface TrackCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  details: String;
  sprints?: Maybe<SprintCreateManyWithoutTrackInput>;
}

export interface SprintUpdateOneRequiredWithoutModulesInput {
  create?: Maybe<SprintCreateWithoutModulesInput>;
  update?: Maybe<SprintUpdateWithoutModulesDataInput>;
  upsert?: Maybe<SprintUpsertWithoutModulesInput>;
  connect?: Maybe<SprintWhereUniqueInput>;
}

export interface LessonUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  objectives?: Maybe<LessonUpdateobjectivesInput>;
  details?: Maybe<String>;
}

export interface SprintUpdateWithoutModulesDataInput {
  name?: Maybe<String>;
  track?: Maybe<TrackUpdateOneRequiredWithoutSprintsInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface TrackUpdateOneRequiredWithoutSprintsInput {
  create?: Maybe<TrackCreateWithoutSprintsInput>;
  update?: Maybe<TrackUpdateWithoutSprintsDataInput>;
  upsert?: Maybe<TrackUpsertWithoutSprintsInput>;
  connect?: Maybe<TrackWhereUniqueInput>;
}

export interface SprintSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SprintWhereInput>;
  AND?: Maybe<SprintSubscriptionWhereInput[] | SprintSubscriptionWhereInput>;
  OR?: Maybe<SprintSubscriptionWhereInput[] | SprintSubscriptionWhereInput>;
  NOT?: Maybe<SprintSubscriptionWhereInput[] | SprintSubscriptionWhereInput>;
}

export interface TrackUpdateWithoutSprintsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  details?: Maybe<String>;
}

export interface ModuleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ModuleWhereInput>;
  AND?: Maybe<ModuleSubscriptionWhereInput[] | ModuleSubscriptionWhereInput>;
  OR?: Maybe<ModuleSubscriptionWhereInput[] | ModuleSubscriptionWhereInput>;
  NOT?: Maybe<ModuleSubscriptionWhereInput[] | ModuleSubscriptionWhereInput>;
}

export interface TrackUpsertWithoutSprintsInput {
  update: TrackUpdateWithoutSprintsDataInput;
  create: TrackCreateWithoutSprintsInput;
}

export interface LessonSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LessonWhereInput>;
  AND?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  OR?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
  NOT?: Maybe<LessonSubscriptionWhereInput[] | LessonSubscriptionWhereInput>;
}

export interface SprintUpsertWithoutModulesInput {
  update: SprintUpdateWithoutModulesDataInput;
  create: SprintCreateWithoutModulesInput;
}

export interface NoteUpdateManyDataInput {
  details?: Maybe<String>;
}

export interface ModuleUpsertWithoutLessonsInput {
  update: ModuleUpdateWithoutLessonsDataInput;
  create: ModuleCreateWithoutLessonsInput;
}

export interface NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput;
  data: NoteUpdateManyDataInput;
}

export interface LessonUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  objectives?: Maybe<LessonUpdateobjectivesInput>;
  details?: Maybe<String>;
}

export interface NoteUpsertWithWhereUniqueWithoutUserInput {
  where: NoteWhereUniqueInput;
  update: NoteUpdateWithoutUserDataInput;
  create: NoteCreateWithoutUserInput;
}

export interface TrackUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  details?: Maybe<String>;
  sprints?: Maybe<SprintUpdateManyWithoutTrackInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  notes_every?: Maybe<NoteWhereInput>;
  notes_some?: Maybe<NoteWhereInput>;
  notes_none?: Maybe<NoteWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface SprintCreateWithoutTrackInput {
  id?: Maybe<ID_Input>;
  name: String;
  modules?: Maybe<ModuleCreateManyWithoutSprintInput>;
}

export interface NoteUpdateWithWhereUniqueWithoutUserInput {
  where: NoteWhereUniqueInput;
  data: NoteUpdateWithoutUserDataInput;
}

export interface ModuleCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  sprint: SprintCreateOneWithoutModulesInput;
  lessons?: Maybe<LessonCreateManyWithoutModuleInput>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  role?: Maybe<Role>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  notes?: Maybe<NoteUpdateManyWithoutUserInput>;
}

export interface LessonCreateManyWithoutModuleInput {
  create?: Maybe<
    LessonCreateWithoutModuleInput[] | LessonCreateWithoutModuleInput
  >;
  connect?: Maybe<LessonWhereUniqueInput[] | LessonWhereUniqueInput>;
}

export interface NoteCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  lesson: LessonCreateOneInput;
  details: String;
}

export interface LessonCreateWithoutModuleInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  objectives?: Maybe<LessonCreateobjectivesInput>;
  details: String;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  role?: Maybe<Role>;
  username: String;
  email: String;
  password: String;
  notes?: Maybe<NoteCreateManyWithoutUserInput>;
}

export interface ModuleUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  sprint?: Maybe<SprintUpdateOneRequiredWithoutModulesInput>;
  lessons?: Maybe<LessonUpdateManyWithoutModuleInput>;
}

export interface TrackUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  details?: Maybe<String>;
}

export interface SprintCreateManyWithoutTrackInput {
  create?: Maybe<
    SprintCreateWithoutTrackInput[] | SprintCreateWithoutTrackInput
  >;
  connect?: Maybe<SprintWhereUniqueInput[] | SprintWhereUniqueInput>;
}

export interface SprintUpdateManyWithWhereNestedInput {
  where: SprintScalarWhereInput;
  data: SprintUpdateManyDataInput;
}

export interface LessonUpdateWithWhereUniqueWithoutModuleInput {
  where: LessonWhereUniqueInput;
  data: LessonUpdateWithoutModuleDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface LessonUpdateWithoutModuleDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  objectives?: Maybe<LessonUpdateobjectivesInput>;
  details?: Maybe<String>;
}

export interface SprintUpdateWithoutTrackDataInput {
  name?: Maybe<String>;
  modules?: Maybe<ModuleUpdateManyWithoutSprintInput>;
}

export interface LessonUpsertWithWhereUniqueWithoutModuleInput {
  where: LessonWhereUniqueInput;
  update: LessonUpdateWithoutModuleDataInput;
  create: LessonCreateWithoutModuleInput;
}

export interface SprintUpdateManyWithoutTrackInput {
  create?: Maybe<
    SprintCreateWithoutTrackInput[] | SprintCreateWithoutTrackInput
  >;
  delete?: Maybe<SprintWhereUniqueInput[] | SprintWhereUniqueInput>;
  connect?: Maybe<SprintWhereUniqueInput[] | SprintWhereUniqueInput>;
  set?: Maybe<SprintWhereUniqueInput[] | SprintWhereUniqueInput>;
  disconnect?: Maybe<SprintWhereUniqueInput[] | SprintWhereUniqueInput>;
  update?: Maybe<
    | SprintUpdateWithWhereUniqueWithoutTrackInput[]
    | SprintUpdateWithWhereUniqueWithoutTrackInput
  >;
  upsert?: Maybe<
    | SprintUpsertWithWhereUniqueWithoutTrackInput[]
    | SprintUpsertWithWhereUniqueWithoutTrackInput
  >;
  deleteMany?: Maybe<SprintScalarWhereInput[] | SprintScalarWhereInput>;
  updateMany?: Maybe<
    | SprintUpdateManyWithWhereNestedInput[]
    | SprintUpdateManyWithWhereNestedInput
  >;
}

export interface LessonScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  OR?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
  NOT?: Maybe<LessonScalarWhereInput[] | LessonScalarWhereInput>;
}

export interface LessonCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  objectives?: Maybe<LessonCreateobjectivesInput>;
  module: ModuleCreateOneWithoutLessonsInput;
  details: String;
}

export interface ModuleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  sprint?: Maybe<SprintWhereInput>;
  lessons_every?: Maybe<LessonWhereInput>;
  lessons_some?: Maybe<LessonWhereInput>;
  lessons_none?: Maybe<LessonWhereInput>;
  AND?: Maybe<ModuleWhereInput[] | ModuleWhereInput>;
  OR?: Maybe<ModuleWhereInput[] | ModuleWhereInput>;
  NOT?: Maybe<ModuleWhereInput[] | ModuleWhereInput>;
}

export interface ModuleCreateOneWithoutLessonsInput {
  create?: Maybe<ModuleCreateWithoutLessonsInput>;
  connect?: Maybe<ModuleWhereUniqueInput>;
}

export interface TrackWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  sprints_every?: Maybe<SprintWhereInput>;
  sprints_some?: Maybe<SprintWhereInput>;
  sprints_none?: Maybe<SprintWhereInput>;
  AND?: Maybe<TrackWhereInput[] | TrackWhereInput>;
  OR?: Maybe<TrackWhereInput[] | TrackWhereInput>;
  NOT?: Maybe<TrackWhereInput[] | TrackWhereInput>;
}

export interface SprintCreateOneWithoutModulesInput {
  create?: Maybe<SprintCreateWithoutModulesInput>;
  connect?: Maybe<SprintWhereUniqueInput>;
}

export interface ModuleUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TrackCreateOneWithoutSprintsInput {
  create?: Maybe<TrackCreateWithoutSprintsInput>;
  connect?: Maybe<TrackWhereUniqueInput>;
}

export interface NoteCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutNotesInput;
  lesson: LessonCreateOneInput;
  details: String;
}

export interface LessonUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  objectives?: Maybe<LessonUpdateobjectivesInput>;
  module?: Maybe<ModuleUpdateOneRequiredWithoutLessonsInput>;
  details?: Maybe<String>;
}

export interface UserCreateOneWithoutNotesInput {
  create?: Maybe<UserCreateWithoutNotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ModuleUpdateOneRequiredWithoutLessonsInput {
  create?: Maybe<ModuleCreateWithoutLessonsInput>;
  update?: Maybe<ModuleUpdateWithoutLessonsDataInput>;
  upsert?: Maybe<ModuleUpsertWithoutLessonsInput>;
  connect?: Maybe<ModuleWhereUniqueInput>;
}

export interface UserCreateWithoutNotesInput {
  id?: Maybe<ID_Input>;
  name: String;
  role?: Maybe<Role>;
  username: String;
  email: String;
  password: String;
}

export interface TrackSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TrackWhereInput>;
  AND?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
  OR?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
  NOT?: Maybe<TrackSubscriptionWhereInput[] | TrackSubscriptionWhereInput>;
}

export interface LessonCreateOneInput {
  create?: Maybe<LessonCreateInput>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export type ModuleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface NoteUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutNotesInput>;
  lesson?: Maybe<LessonUpdateOneRequiredInput>;
  details?: Maybe<String>;
}

export type NoteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutNotesInput {
  create?: Maybe<UserCreateWithoutNotesInput>;
  update?: Maybe<UserUpdateWithoutNotesDataInput>;
  upsert?: Maybe<UserUpsertWithoutNotesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface NoteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  lesson?: Maybe<LessonWhereInput>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  OR?: Maybe<NoteWhereInput[] | NoteWhereInput>;
  NOT?: Maybe<NoteWhereInput[] | NoteWhereInput>;
}

export interface UserUpdateWithoutNotesDataInput {
  name?: Maybe<String>;
  role?: Maybe<Role>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface NoteUpdateManyWithoutUserInput {
  create?: Maybe<NoteCreateWithoutUserInput[] | NoteCreateWithoutUserInput>;
  delete?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  set?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  disconnect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
  update?: Maybe<
    | NoteUpdateWithWhereUniqueWithoutUserInput[]
    | NoteUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | NoteUpsertWithWhereUniqueWithoutUserInput[]
    | NoteUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  updateMany?: Maybe<
    NoteUpdateManyWithWhereNestedInput[] | NoteUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpsertWithoutNotesInput {
  update: UserUpdateWithoutNotesDataInput;
  create: UserCreateWithoutNotesInput;
}

export interface NoteCreateManyWithoutUserInput {
  create?: Maybe<NoteCreateWithoutUserInput[] | NoteCreateWithoutUserInput>;
  connect?: Maybe<NoteWhereUniqueInput[] | NoteWhereUniqueInput>;
}

export interface LessonUpdateOneRequiredInput {
  create?: Maybe<LessonCreateInput>;
  update?: Maybe<LessonUpdateDataInput>;
  upsert?: Maybe<LessonUpsertNestedInput>;
  connect?: Maybe<LessonWhereUniqueInput>;
}

export interface SprintUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface LessonUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  objectives?: Maybe<LessonUpdateobjectivesInput>;
  module?: Maybe<ModuleUpdateOneRequiredWithoutLessonsInput>;
  details?: Maybe<String>;
}

export interface SprintUpsertWithWhereUniqueWithoutTrackInput {
  where: SprintWhereUniqueInput;
  update: SprintUpdateWithoutTrackDataInput;
  create: SprintCreateWithoutTrackInput;
}

export interface LessonUpsertNestedInput {
  update: LessonUpdateDataInput;
  create: LessonCreateInput;
}

export interface ModuleCreateWithoutLessonsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  sprint: SprintCreateOneWithoutModulesInput;
}

export interface NoteUpdateManyMutationInput {
  details?: Maybe<String>;
}

export interface TrackCreateWithoutSprintsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  details: String;
}

export interface SprintCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  track: TrackCreateOneWithoutSprintsInput;
  modules?: Maybe<ModuleCreateManyWithoutSprintInput>;
}

export interface SprintWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  track?: Maybe<TrackWhereInput>;
  modules_every?: Maybe<ModuleWhereInput>;
  modules_some?: Maybe<ModuleWhereInput>;
  modules_none?: Maybe<ModuleWhereInput>;
  AND?: Maybe<SprintWhereInput[] | SprintWhereInput>;
  OR?: Maybe<SprintWhereInput[] | SprintWhereInput>;
  NOT?: Maybe<SprintWhereInput[] | SprintWhereInput>;
}

export interface ModuleCreateManyWithoutSprintInput {
  create?: Maybe<
    ModuleCreateWithoutSprintInput[] | ModuleCreateWithoutSprintInput
  >;
  connect?: Maybe<ModuleWhereUniqueInput[] | ModuleWhereUniqueInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  role?: Maybe<Role>;
  username?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
}

export interface ModuleCreateWithoutSprintInput {
  id?: Maybe<ID_Input>;
  name: String;
  description: String;
  lessons?: Maybe<LessonCreateManyWithoutModuleInput>;
}

export interface NoteUpdateWithoutUserDataInput {
  lesson?: Maybe<LessonUpdateOneRequiredInput>;
  details?: Maybe<String>;
}

export interface SprintUpdateInput {
  name?: Maybe<String>;
  track?: Maybe<TrackUpdateOneRequiredWithoutSprintsInput>;
  modules?: Maybe<ModuleUpdateManyWithoutSprintInput>;
}

export type TrackWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ModuleUpdateManyWithoutSprintInput {
  create?: Maybe<
    ModuleCreateWithoutSprintInput[] | ModuleCreateWithoutSprintInput
  >;
  delete?: Maybe<ModuleWhereUniqueInput[] | ModuleWhereUniqueInput>;
  connect?: Maybe<ModuleWhereUniqueInput[] | ModuleWhereUniqueInput>;
  set?: Maybe<ModuleWhereUniqueInput[] | ModuleWhereUniqueInput>;
  disconnect?: Maybe<ModuleWhereUniqueInput[] | ModuleWhereUniqueInput>;
  update?: Maybe<
    | ModuleUpdateWithWhereUniqueWithoutSprintInput[]
    | ModuleUpdateWithWhereUniqueWithoutSprintInput
  >;
  upsert?: Maybe<
    | ModuleUpsertWithWhereUniqueWithoutSprintInput[]
    | ModuleUpsertWithWhereUniqueWithoutSprintInput
  >;
  deleteMany?: Maybe<ModuleScalarWhereInput[] | ModuleScalarWhereInput>;
  updateMany?: Maybe<
    | ModuleUpdateManyWithWhereNestedInput[]
    | ModuleUpdateManyWithWhereNestedInput
  >;
}

export interface SprintUpdateWithWhereUniqueWithoutTrackInput {
  where: SprintWhereUniqueInput;
  data: SprintUpdateWithoutTrackDataInput;
}

export interface ModuleUpdateWithWhereUniqueWithoutSprintInput {
  where: ModuleWhereUniqueInput;
  data: ModuleUpdateWithoutSprintDataInput;
}

export interface SprintCreateWithoutModulesInput {
  id?: Maybe<ID_Input>;
  name: String;
  track: TrackCreateOneWithoutSprintsInput;
}

export interface ModuleUpdateWithoutSprintDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  lessons?: Maybe<LessonUpdateManyWithoutModuleInput>;
}

export interface NoteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NoteWhereInput>;
  AND?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  OR?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
  NOT?: Maybe<NoteSubscriptionWhereInput[] | NoteSubscriptionWhereInput>;
}

export interface ModuleUpsertWithWhereUniqueWithoutSprintInput {
  where: ModuleWhereUniqueInput;
  update: ModuleUpdateWithoutSprintDataInput;
  create: ModuleCreateWithoutSprintInput;
}

export type SprintWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface SprintUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ModuleUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
}

export interface ModuleUpdateManyWithWhereNestedInput {
  where: ModuleScalarWhereInput;
  data: ModuleUpdateManyDataInput;
}

export interface ModuleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ModuleScalarWhereInput[] | ModuleScalarWhereInput>;
  OR?: Maybe<ModuleScalarWhereInput[] | ModuleScalarWhereInput>;
  NOT?: Maybe<ModuleScalarWhereInput[] | ModuleScalarWhereInput>;
}

export interface SprintScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SprintScalarWhereInput[] | SprintScalarWhereInput>;
  OR?: Maybe<SprintScalarWhereInput[] | SprintScalarWhereInput>;
  NOT?: Maybe<SprintScalarWhereInput[] | SprintScalarWhereInput>;
}

export interface NoteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  details?: Maybe<String>;
  details_not?: Maybe<String>;
  details_in?: Maybe<String[] | String>;
  details_not_in?: Maybe<String[] | String>;
  details_lt?: Maybe<String>;
  details_lte?: Maybe<String>;
  details_gt?: Maybe<String>;
  details_gte?: Maybe<String>;
  details_contains?: Maybe<String>;
  details_not_contains?: Maybe<String>;
  details_starts_with?: Maybe<String>;
  details_not_starts_with?: Maybe<String>;
  details_ends_with?: Maybe<String>;
  details_not_ends_with?: Maybe<String>;
  AND?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  OR?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
  NOT?: Maybe<NoteScalarWhereInput[] | NoteScalarWhereInput>;
}

export interface LessonUpdateobjectivesInput {
  set?: Maybe<String[] | String>;
}

export interface LessonCreateobjectivesInput {
  set?: Maybe<String[] | String>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  role: Role;
  username: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  name: String;
  role: Role;
  username: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  username: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  notes: <T = Promise<AsyncIterator<NoteSubscription>>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  role: () => Promise<Role>;
  username: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  notes: <T = FragmentableArray<Note>>(args?: {
    where?: NoteWhereInput;
    orderBy?: NoteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrackSubscriptionPayload {
  mutation: MutationType;
  node: Track;
  updatedFields: String[];
  previousValues: TrackPreviousValues;
}

export interface TrackSubscriptionPayloadPromise
  extends Promise<TrackSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TrackPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TrackPreviousValuesPromise>() => T;
}

export interface TrackSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TrackSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TrackSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TrackPreviousValuesSubscription>() => T;
}

export interface Note {
  id: ID_Output;
  details: String;
}

export interface NotePromise extends Promise<Note>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  lesson: <T = LessonPromise>() => T;
  details: () => Promise<String>;
}

export interface NoteSubscription
  extends Promise<AsyncIterator<Note>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  lesson: <T = LessonSubscription>() => T;
  details: () => Promise<AsyncIterator<String>>;
}

export interface NoteNullablePromise
  extends Promise<Note | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  lesson: <T = LessonPromise>() => T;
  details: () => Promise<String>;
}

export interface AggregateModule {
  count: Int;
}

export interface AggregateModulePromise
  extends Promise<AggregateModule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateModuleSubscription
  extends Promise<AsyncIterator<AggregateModule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ModuleEdge {
  node: Module;
  cursor: String;
}

export interface ModuleEdgePromise extends Promise<ModuleEdge>, Fragmentable {
  node: <T = ModulePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ModuleEdgeSubscription
  extends Promise<AsyncIterator<ModuleEdge>>,
    Fragmentable {
  node: <T = ModuleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ModuleConnection {
  pageInfo: PageInfo;
  edges: ModuleEdge[];
}

export interface ModuleConnectionPromise
  extends Promise<ModuleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ModuleEdge>>() => T;
  aggregate: <T = AggregateModulePromise>() => T;
}

export interface ModuleConnectionSubscription
  extends Promise<AsyncIterator<ModuleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ModuleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateModuleSubscription>() => T;
}

export interface AggregateTrack {
  count: Int;
}

export interface AggregateTrackPromise
  extends Promise<AggregateTrack>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTrackSubscription
  extends Promise<AsyncIterator<AggregateTrack>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonConnection {
  pageInfo: PageInfo;
  edges: LessonEdge[];
}

export interface LessonConnectionPromise
  extends Promise<LessonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LessonEdge>>() => T;
  aggregate: <T = AggregateLessonPromise>() => T;
}

export interface LessonConnectionSubscription
  extends Promise<AsyncIterator<LessonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LessonEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLessonSubscription>() => T;
}

export interface TrackConnection {
  pageInfo: PageInfo;
  edges: TrackEdge[];
}

export interface TrackConnectionPromise
  extends Promise<TrackConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TrackEdge>>() => T;
  aggregate: <T = AggregateTrackPromise>() => T;
}

export interface TrackConnectionSubscription
  extends Promise<AsyncIterator<TrackConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TrackEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTrackSubscription>() => T;
}

export interface LessonSubscriptionPayload {
  mutation: MutationType;
  node: Lesson;
  updatedFields: String[];
  previousValues: LessonPreviousValues;
}

export interface LessonSubscriptionPayloadPromise
  extends Promise<LessonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LessonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LessonPreviousValuesPromise>() => T;
}

export interface LessonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LessonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LessonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LessonPreviousValuesSubscription>() => T;
}

export interface AggregateSprint {
  count: Int;
}

export interface AggregateSprintPromise
  extends Promise<AggregateSprint>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSprintSubscription
  extends Promise<AsyncIterator<AggregateSprint>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LessonPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  objectives: String[];
  details: String;
}

export interface LessonPreviousValuesPromise
  extends Promise<LessonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  objectives: () => Promise<String[]>;
  details: () => Promise<String>;
}

export interface LessonPreviousValuesSubscription
  extends Promise<AsyncIterator<LessonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  objectives: () => Promise<AsyncIterator<String[]>>;
  details: () => Promise<AsyncIterator<String>>;
}

export interface SprintConnection {
  pageInfo: PageInfo;
  edges: SprintEdge[];
}

export interface SprintConnectionPromise
  extends Promise<SprintConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SprintEdge>>() => T;
  aggregate: <T = AggregateSprintPromise>() => T;
}

export interface SprintConnectionSubscription
  extends Promise<AsyncIterator<SprintConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SprintEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSprintSubscription>() => T;
}

export interface AggregateLesson {
  count: Int;
}

export interface AggregateLessonPromise
  extends Promise<AggregateLesson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLessonSubscription
  extends Promise<AsyncIterator<AggregateLesson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NoteEdge {
  node: Note;
  cursor: String;
}

export interface NoteEdgePromise extends Promise<NoteEdge>, Fragmentable {
  node: <T = NotePromise>() => T;
  cursor: () => Promise<String>;
}

export interface NoteEdgeSubscription
  extends Promise<AsyncIterator<NoteEdge>>,
    Fragmentable {
  node: <T = NoteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ModuleSubscriptionPayload {
  mutation: MutationType;
  node: Module;
  updatedFields: String[];
  previousValues: ModulePreviousValues;
}

export interface ModuleSubscriptionPayloadPromise
  extends Promise<ModuleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ModulePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ModulePreviousValuesPromise>() => T;
}

export interface ModuleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ModuleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ModuleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ModulePreviousValuesSubscription>() => T;
}

export interface Sprint {
  id: ID_Output;
  name: String;
}

export interface SprintPromise extends Promise<Sprint>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  track: <T = TrackPromise>() => T;
  modules: <T = FragmentableArray<Module>>(args?: {
    where?: ModuleWhereInput;
    orderBy?: ModuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SprintSubscription
  extends Promise<AsyncIterator<Sprint>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  track: <T = TrackSubscription>() => T;
  modules: <T = Promise<AsyncIterator<ModuleSubscription>>>(args?: {
    where?: ModuleWhereInput;
    orderBy?: ModuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SprintNullablePromise
  extends Promise<Sprint | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  track: <T = TrackPromise>() => T;
  modules: <T = FragmentableArray<Module>>(args?: {
    where?: ModuleWhereInput;
    orderBy?: ModuleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ModulePreviousValues {
  id: ID_Output;
  name: String;
  description: String;
}

export interface ModulePreviousValuesPromise
  extends Promise<ModulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
}

export interface ModulePreviousValuesSubscription
  extends Promise<AsyncIterator<ModulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface LessonEdge {
  node: Lesson;
  cursor: String;
}

export interface LessonEdgePromise extends Promise<LessonEdge>, Fragmentable {
  node: <T = LessonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LessonEdgeSubscription
  extends Promise<AsyncIterator<LessonEdge>>,
    Fragmentable {
  node: <T = LessonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Lesson {
  id: ID_Output;
  name: String;
  description: String;
  objectives: String[];
  details: String;
}

export interface LessonPromise extends Promise<Lesson>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  objectives: () => Promise<String[]>;
  module: <T = ModulePromise>() => T;
  details: () => Promise<String>;
}

export interface LessonSubscription
  extends Promise<AsyncIterator<Lesson>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  objectives: () => Promise<AsyncIterator<String[]>>;
  module: <T = ModuleSubscription>() => T;
  details: () => Promise<AsyncIterator<String>>;
}

export interface LessonNullablePromise
  extends Promise<Lesson | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  objectives: () => Promise<String[]>;
  module: <T = ModulePromise>() => T;
  details: () => Promise<String>;
}

export interface NoteSubscriptionPayload {
  mutation: MutationType;
  node: Note;
  updatedFields: String[];
  previousValues: NotePreviousValues;
}

export interface NoteSubscriptionPayloadPromise
  extends Promise<NoteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NotePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NotePreviousValuesPromise>() => T;
}

export interface NoteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NoteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NoteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NotePreviousValuesSubscription>() => T;
}

export interface Module {
  id: ID_Output;
  name: String;
  description: String;
}

export interface ModulePromise extends Promise<Module>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  sprint: <T = SprintPromise>() => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ModuleSubscription
  extends Promise<AsyncIterator<Module>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  sprint: <T = SprintSubscription>() => T;
  lessons: <T = Promise<AsyncIterator<LessonSubscription>>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ModuleNullablePromise
  extends Promise<Module | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  sprint: <T = SprintPromise>() => T;
  lessons: <T = FragmentableArray<Lesson>>(args?: {
    where?: LessonWhereInput;
    orderBy?: LessonOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NotePreviousValues {
  id: ID_Output;
  details: String;
}

export interface NotePreviousValuesPromise
  extends Promise<NotePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  details: () => Promise<String>;
}

export interface NotePreviousValuesSubscription
  extends Promise<AsyncIterator<NotePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  details: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNote {
  count: Int;
}

export interface AggregateNotePromise
  extends Promise<AggregateNote>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNoteSubscription
  extends Promise<AsyncIterator<AggregateNote>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Track {
  id: ID_Output;
  name: String;
  description: String;
  details: String;
}

export interface TrackPromise extends Promise<Track>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  details: () => Promise<String>;
  sprints: <T = FragmentableArray<Sprint>>(args?: {
    where?: SprintWhereInput;
    orderBy?: SprintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrackSubscription
  extends Promise<AsyncIterator<Track>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  details: () => Promise<AsyncIterator<String>>;
  sprints: <T = Promise<AsyncIterator<SprintSubscription>>>(args?: {
    where?: SprintWhereInput;
    orderBy?: SprintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TrackNullablePromise
  extends Promise<Track | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  details: () => Promise<String>;
  sprints: <T = FragmentableArray<Sprint>>(args?: {
    where?: SprintWhereInput;
    orderBy?: SprintOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface SprintPreviousValues {
  id: ID_Output;
  name: String;
}

export interface SprintPreviousValuesPromise
  extends Promise<SprintPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SprintPreviousValuesSubscription
  extends Promise<AsyncIterator<SprintPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SprintSubscriptionPayload {
  mutation: MutationType;
  node: Sprint;
  updatedFields: String[];
  previousValues: SprintPreviousValues;
}

export interface SprintSubscriptionPayloadPromise
  extends Promise<SprintSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SprintPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SprintPreviousValuesPromise>() => T;
}

export interface SprintSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SprintSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SprintSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SprintPreviousValuesSubscription>() => T;
}

export interface TrackPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  details: String;
}

export interface TrackPreviousValuesPromise
  extends Promise<TrackPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  details: () => Promise<String>;
}

export interface TrackPreviousValuesSubscription
  extends Promise<AsyncIterator<TrackPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  details: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NoteConnection {
  pageInfo: PageInfo;
  edges: NoteEdge[];
}

export interface NoteConnectionPromise
  extends Promise<NoteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NoteEdge>>() => T;
  aggregate: <T = AggregateNotePromise>() => T;
}

export interface NoteConnectionSubscription
  extends Promise<AsyncIterator<NoteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NoteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNoteSubscription>() => T;
}

export interface SprintEdge {
  node: Sprint;
  cursor: String;
}

export interface SprintEdgePromise extends Promise<SprintEdge>, Fragmentable {
  node: <T = SprintPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SprintEdgeSubscription
  extends Promise<AsyncIterator<SprintEdge>>,
    Fragmentable {
  node: <T = SprintSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TrackEdge {
  node: Track;
  cursor: String;
}

export interface TrackEdgePromise extends Promise<TrackEdge>, Fragmentable {
  node: <T = TrackPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TrackEdgeSubscription
  extends Promise<AsyncIterator<TrackEdge>>,
    Fragmentable {
  node: <T = TrackSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Track",
    embedded: false
  },
  {
    name: "Sprint",
    embedded: false
  },
  {
    name: "Module",
    embedded: false
  },
  {
    name: "Lesson",
    embedded: false
  },
  {
    name: "Note",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
